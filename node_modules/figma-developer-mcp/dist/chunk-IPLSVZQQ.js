import{StdioServerTransport as ye}from"@modelcontextprotocol/sdk/server/stdio.js";import{config as he}from"dotenv";import{resolve as Se}from"path";import{config as X}from"dotenv";import Y from"yargs";import{hideBin as J}from"yargs/helpers";X();function Z(e){return e.length<=4?"****":`****${e.slice(-4)}`}function N(e){let t=Y(J(process.argv)).options({"figma-api-key":{type:"string",description:"Figma API key"},port:{type:"number",description:"Port to run the server on"}}).help().version("0.2.1").parseSync(),i={figmaApiKey:"",port:3333,configSources:{figmaApiKey:"env",port:"default"}};return t["figma-api-key"]?(i.figmaApiKey=t["figma-api-key"],i.configSources.figmaApiKey="cli"):process.env.FIGMA_API_KEY&&(i.figmaApiKey=process.env.FIGMA_API_KEY,i.configSources.figmaApiKey="env"),t.port?(i.port=t.port,i.configSources.port="cli"):process.env.PORT&&(i.port=parseInt(process.env.PORT,10),i.configSources.port="env"),i.figmaApiKey||(console.error("FIGMA_API_KEY is required (via CLI argument --figma-api-key or .env file)"),process.exit(1)),e||(console.log(`
Configuration:`),console.log(`- FIGMA_API_KEY: ${Z(i.figmaApiKey)} (source: ${i.configSources.figmaApiKey})`),console.log(`- PORT: ${i.port} (source: ${i.configSources.port})`),console.log()),i}import{randomUUID as Q}from"node:crypto";import B from"express";import{SSEServerTransport as ee}from"@modelcontextprotocol/sdk/server/sse.js";import{StreamableHTTPServerTransport as te}from"@modelcontextprotocol/sdk/server/streamableHttp.js";import{isInitializeRequest as ie}from"@modelcontextprotocol/sdk/types.js";import"@modelcontextprotocol/sdk/server/mcp.js";var c={isHTTP:!1,log:(...e)=>{c.isHTTP?console.log("[INFO]",...e):console.error("[INFO]",...e)},error:(...e)=>{console.error("[ERROR]",...e)}};var oe=null,m={streamable:{},sse:{}};async function k(e,t){let i=B();i.use("/mcp",B.json()),i.post("/mcp",async(o,s)=>{c.log("Received StreamableHTTP request");let n=o.headers["mcp-session-id"],l;if(n&&m.streamable[n])c.log("Reusing existing StreamableHTTP transport for sessionId",n),l=m.streamable[n];else if(!n&&ie(o.body))c.log("New initialization request for StreamableHTTP sessionId",n),l=new te({sessionIdGenerator:()=>Q(),onsessioninitialized:f=>{m.streamable[f]=l}}),l.onclose=()=>{l.sessionId&&delete m.streamable[l.sessionId]},await t.connect(l);else{c.log("Invalid request:",o.body),s.status(400).json({jsonrpc:"2.0",error:{code:-32e3,message:"Bad Request: No valid session ID provided"},id:null});return}let d=null,g=o.body.params?._meta?.progressToken,a=0;g&&(c.log(`Setting up progress notifications for token ${g} on session ${n}`),d=setInterval(async()=>{c.log("Sending progress notification",a),await t.server.notification({method:"notifications/progress",params:{progress:a,progressToken:g}}),a++},1e3)),c.log("Handling StreamableHTTP request"),await l.handleRequest(o,s,o.body),d&&clearInterval(d),c.log("StreamableHTTP request handled")});let r=async(o,s)=>{let n=o.headers["mcp-session-id"];if(!n||!m.streamable[n]){s.status(400).send("Invalid or missing session ID");return}console.log(`Received session termination request for session ${n}`);try{await m.streamable[n].handleRequest(o,s)}catch(l){console.error("Error handling session termination:",l),s.headersSent||s.status(500).send("Error processing session termination")}};i.get("/mcp",r),i.delete("/mcp",r),i.get("/sse",async(o,s)=>{c.log("Establishing new SSE connection");let n=new ee("/messages",s);c.log(`New SSE connection established for sessionId ${n.sessionId}`),c.log("/sse request headers:",o.headers),c.log("/sse request body:",o.body),m.sse[n.sessionId]=n,s.on("close",()=>{delete m.sse[n.sessionId]}),await t.connect(n)}),i.post("/messages",async(o,s)=>{let n=o.query.sessionId,l=m.sse[n];if(l)c.log(`Received SSE message for sessionId ${n}`),c.log("/messages request headers:",o.headers),c.log("/messages request body:",o.body),await l.handlePostMessage(o,s);else{s.status(400).send(`No transport found for sessionId ${n}`);return}}),oe=i.listen(e,()=>{c.log(`HTTP server listening on port ${e}`),c.log(`SSE endpoint available at http://localhost:${e}/sse`),c.log(`Message endpoint available at http://localhost:${e}/messages`),c.log(`StreamableHTTP endpoint available at http://localhost:${e}/mcp`)}),process.on("SIGINT",async()=>{c.log("Shutting down server..."),await C(m.sse),await C(m.streamable),c.log("Server shutdown complete"),process.exit(0)})}async function C(e){for(let t in e)try{await e[t]?.close(),delete e[t]}catch(i){console.error(`Error closing transport for session ${t}:`,i)}}import{McpServer as ge}from"@modelcontextprotocol/sdk/server/mcp.js";import{z as u}from"zod";import x from"fs";import{isTruthy as H}from"remeda";function p(e,t,i){if(!(typeof t=="object"&&t!==null)||!(e in t))return!1;let o=t[e];return i?i(o):o!==void 0}function F(e){return typeof e=="object"&&!!e&&"clipsContent"in e&&typeof e.clipsContent=="boolean"}function D(e){return typeof e=="object"&&!!e&&"absoluteBoundingBox"in e&&typeof e.absoluteBoundingBox=="object"&&!!e.absoluteBoundingBox&&"x"in e.absoluteBoundingBox&&"y"in e.absoluteBoundingBox&&"width"in e.absoluteBoundingBox&&"height"in e.absoluteBoundingBox}function G(e){return typeof e=="object"&&e!==null&&"top"in e&&"right"in e&&"bottom"in e&&"left"in e}function E(e,t){let i=t;return typeof t=="object"&&!!t&&e in i&&typeof i[e]=="object"&&!!i[e]&&"x"in i[e]&&"y"in i[e]&&"width"in i[e]&&"height"in i[e]}function L(e){return Array.isArray(e)&&e.length===4&&e.every(t=>typeof t=="number")}import h from"fs";import re from"path";async function A(e,t,i){try{h.existsSync(t)||h.mkdirSync(t,{recursive:!0});let r=re.join(t,e),o=await fetch(i,{method:"GET"});if(!o.ok)throw new Error(`Failed to download image: ${o.statusText}`);let s=h.createWriteStream(r),n=o.body?.getReader();if(!n)throw new Error("Failed to get response body");return new Promise((l,d)=>{let g=async()=>{try{for(;;){let{done:a,value:f}=await n.read();if(a){s.end();break}s.write(f)}l(r)}catch(a){s.end(),h.unlink(r,()=>{}),d(a)}};s.on("error",a=>{n.cancel(),h.unlink(r,()=>{}),d(new Error(`Failed to write image: ${a.message}`))}),g()})}catch(r){let o=r instanceof Error?r.message:String(r);throw new Error(`Error downloading image: ${o}`)}}function w(e){if(typeof e!="object"||e===null)return e;if(Array.isArray(e))return e.map(i=>w(i));let t={};for(let i in e)if(Object.prototype.hasOwnProperty.call(e,i)){let r=e[i],o=w(r);o!==void 0&&!(Array.isArray(o)&&o.length===0)&&!(typeof o=="object"&&o!==null&&Object.keys(o).length===0)&&(t[i]=o)}return t}function M(e,t=1){let i=Math.round(e.r*255),r=Math.round(e.g*255),o=Math.round(e.b*255),s=Math.round(t*e.a*100)/100;return{hex:"#"+((1<<24)+(i<<16)+(r<<8)+o).toString(16).slice(1).toUpperCase(),opacity:s}}function I(e,t=1){let i=Math.round(e.r*255),r=Math.round(e.g*255),o=Math.round(e.b*255),s=Math.round(t*e.a*100)/100;return`rgba(${i}, ${r}, ${o}, ${s})`}function O(e="var"){let t="ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",i="";for(let r=0;r<6;r++){let o=Math.floor(Math.random()*t.length);i+=t[o]}return`${e}_${i}`}function T(e,{ignoreZero:t=!0,suffix:i="px"}={}){let{top:r,right:o,bottom:s,left:n}=e;if(!(t&&r===0&&o===0&&s===0&&n===0))return r===o&&o===s&&s===n?`${r}${i}`:o===n?r===s?`${r}${i} ${o}${i}`:`${r}${i} ${o}${i} ${s}${i}`:`${r}${i} ${o}${i} ${s}${i} ${n}${i}`}function v(e){if(e.type==="IMAGE")return{type:"IMAGE",imageRef:e.imageRef,scaleMode:e.scaleMode};if(e.type==="SOLID"){let{hex:t,opacity:i}=M(e.color,e.opacity);return i===1?t:I(e.color,i)}else{if(["GRADIENT_LINEAR","GRADIENT_RADIAL","GRADIENT_ANGULAR","GRADIENT_DIAMOND"].includes(e.type))return{type:e.type,gradientHandlePositions:e.gradientHandlePositions,gradientStops:e.gradientStops.map(({position:t,color:i})=>({position:t,color:M(i)}))};throw new Error(`Unknown paint type: ${e.type}`)}}function S(e){return e.visible??!0}function j(e,t){let i=ae(e),r=le(e,t,i.mode)||{};return{...i,...r}}function V(e,t){if(t&&t.mode!=="none"){let{children:i,mode:r,axis:o}=t,s=se(o,r);if(i.length>0&&i.reduce((l,d)=>l?"layoutPositioning"in d&&d.layoutPositioning==="ABSOLUTE"?!0:s==="horizontal"?"layoutSizingHorizontal"in d&&d.layoutSizingHorizontal==="FILL":s==="vertical"?"layoutSizingVertical"in d&&d.layoutSizingVertical==="FILL":!1:!1,!0))return"stretch"}switch(e){case"MIN":return;case"MAX":return"flex-end";case"CENTER":return"center";case"SPACE_BETWEEN":return"space-between";case"BASELINE":return"baseline";default:return}}function ne(e){switch(e){case"MIN":return;case"MAX":return"flex-end";case"CENTER":return"center";case"STRETCH":return"stretch";default:return}}function z(e){if(e==="FIXED")return"fixed";if(e==="FILL")return"fill";if(e==="HUG")return"hug"}function se(e,t){switch(e){case"primary":switch(t){case"row":return"horizontal";case"column":return"vertical"}case"counter":switch(t){case"row":return"horizontal";case"column":return"vertical"}}}function ae(e){if(!F(e))return{mode:"none"};let t={mode:!e.layoutMode||e.layoutMode==="NONE"?"none":e.layoutMode==="HORIZONTAL"?"row":"column"},i=[];return e.overflowDirection?.includes("HORIZONTAL")&&i.push("x"),e.overflowDirection?.includes("VERTICAL")&&i.push("y"),i.length>0&&(t.overflowScroll=i),t.mode==="none"||(t.justifyContent=V(e.primaryAxisAlignItems??"MIN",{children:e.children,axis:"primary",mode:t.mode}),t.alignItems=V(e.counterAxisAlignItems??"MIN",{children:e.children,axis:"counter",mode:t.mode}),t.alignSelf=ne(e.layoutAlign),t.wrap=e.layoutWrap==="WRAP"?!0:void 0,t.gap=e.itemSpacing?`${e.itemSpacing??0}px`:void 0,(e.paddingTop||e.paddingBottom||e.paddingLeft||e.paddingRight)&&(t.padding=T({top:e.paddingTop??0,right:e.paddingRight??0,bottom:e.paddingBottom??0,left:e.paddingLeft??0}))),t}function le(e,t,i){if(!D(e))return;let r={mode:i};if(r.sizing={horizontal:z(e.layoutSizingHorizontal),vertical:z(e.layoutSizingVertical)},F(t)&&(t?.layoutMode==="NONE"||e.layoutPositioning==="ABSOLUTE"))return e.layoutPositioning==="ABSOLUTE"&&(r.position="absolute"),e.absoluteBoundingBox&&t.absoluteBoundingBox&&(r.locationRelativeToParent={x:e.absoluteBoundingBox.x-(t?.absoluteBoundingBox?.x??e.absoluteBoundingBox.x),y:e.absoluteBoundingBox.y-(t?.absoluteBoundingBox?.y??e.absoluteBoundingBox.y)}),r;if(E("absoluteBoundingBox",e)&&E("absoluteBoundingBox",t)){let o={};i==="row"?(!e.layoutGrow&&e.layoutSizingHorizontal=="FIXED"&&(o.width=e.absoluteBoundingBox.width),e.layoutAlign!=="STRETCH"&&e.layoutSizingVertical=="FIXED"&&(o.height=e.absoluteBoundingBox.height)):i==="column"&&(e.layoutAlign!=="STRETCH"&&e.layoutSizingHorizontal=="FIXED"&&(o.width=e.absoluteBoundingBox.width),!e.layoutGrow&&e.layoutSizingVertical=="FIXED"&&(o.height=e.absoluteBoundingBox.height),e.preserveRatio&&(o.aspectRatio=e.absoluteBoundingBox?.width/e.absoluteBoundingBox?.height)),Object.keys(o).length>0&&(r.dimensions=o)}return r}function K(e){let t={colors:[]};return p("strokes",e)&&Array.isArray(e.strokes)&&e.strokes.length&&(t.colors=e.strokes.filter(S).map(v)),p("strokeWeight",e)&&typeof e.strokeWeight=="number"&&e.strokeWeight>0&&(t.strokeWeight=`${e.strokeWeight}px`),p("strokeDashes",e)&&Array.isArray(e.strokeDashes)&&e.strokeDashes.length&&(t.strokeDashes=e.strokeDashes),p("individualStrokeWeights",e,G)&&(t.strokeWeight=T(e.individualStrokeWeights)),t}function _(e){if(!p("effects",e))return{};let t=e.effects.filter(d=>d.visible),i=t.filter(d=>d.type==="DROP_SHADOW").map(ce),r=t.filter(d=>d.type==="INNER_SHADOW").map(de),o=[...i,...r].join(", "),s=t.filter(d=>d.type==="LAYER_BLUR").map(W).join(" "),n=t.filter(d=>d.type==="BACKGROUND_BLUR").map(W).join(" "),l={};return o&&(l.boxShadow=o),s&&(l.filter=s),n&&(l.backdropFilter=n),l}function ce(e){return`${e.offset.x}px ${e.offset.y}px ${e.radius}px ${e.spread??0}px ${I(e.color)}`}function de(e){return`inset ${e.offset.x}px ${e.offset.y}px ${e.radius}px ${e.spread??0}px ${I(e.color)}`}function W(e){return`blur(${e.radius}px)`}function P(e){let{name:t,lastModified:i,thumbnailUrl:r}=e,o;"document"in e?o=Object.values(e.document.children):o=Object.values(e.nodes).map(l=>l.document);let s={styles:{}},n=o.filter(S).map(l=>U(s,l)).filter(l=>l!=null);return{name:t,lastModified:i,thumbnailUrl:r||"",nodes:n,globalVars:s}}function b(e,t,i){let[r]=Object.entries(e.styles).find(([s,n])=>JSON.stringify(n)===JSON.stringify(t))??[];if(r)return r;let o=O(i);return e.styles[o]=t,o}function U(e,t,i){let{id:r,name:o,type:s}=t,n={id:r,name:o,type:s};if(p("style",t)&&Object.keys(t.style).length){let a=t.style,f={fontFamily:a.fontFamily,fontWeight:a.fontWeight,fontSize:a.fontSize,lineHeight:a.lineHeightPx&&a.fontSize?`${a.lineHeightPx/a.fontSize}em`:void 0,letterSpacing:a.letterSpacing&&a.letterSpacing!==0&&a.fontSize?`${a.letterSpacing/a.fontSize*100}%`:void 0,textCase:a.textCase,textAlignHorizontal:a.textAlignHorizontal,textAlignVertical:a.textAlignVertical};n.textStyle=b(e,f,"style")}if(p("fills",t)&&Array.isArray(t.fills)&&t.fills.length){let a=t.fills.map(v);n.fills=b(e,a,"fill")}let l=K(t);l.colors.length&&(n.strokes=b(e,l,"stroke"));let d=_(t);Object.keys(d).length&&(n.effects=b(e,d,"effect"));let g=j(t,i);if(Object.keys(g).length>1&&(n.layout=b(e,g,"layout")),p("characters",t,H)&&(n.text=t.characters),p("opacity",t)&&typeof t.opacity=="number"&&t.opacity!==1&&(n.opacity=t.opacity),p("cornerRadius",t)&&typeof t.cornerRadius=="number"&&(n.borderRadius=`${t.cornerRadius}px`),p("rectangleCornerRadii",t,L)&&(n.borderRadius=`${t.rectangleCornerRadii[0]}px ${t.rectangleCornerRadii[1]}px ${t.rectangleCornerRadii[2]}px ${t.rectangleCornerRadii[3]}px`),p("children",t)&&t.children.length>0){let a=t.children.filter(S).map(f=>U(e,f,t)).filter(f=>f!=null);a.length&&(n.children=a)}return s==="VECTOR"&&(n.type="IMAGE-SVG"),w(n)}import fe from"js-yaml";var $=class{apiKey;baseUrl="https://api.figma.com/v1";constructor(t){this.apiKey=t}async request(t){if(typeof fetch!="function")throw new Error("The MCP server is being run in a Node.js environment where `fetch` is not available. You won't be able to access any data related to the Figma file.\n\nAs the coding AI assistant, PLEASE ABORT THE CURRENT REQUEST. No alternate approaches will work. Help the user fix this issue so you can proceed by letting them know that they need to run the MCP server with Node.js version 18 or higher.");try{c.log(`Calling ${this.baseUrl}${t}`);let i=await fetch(`${this.baseUrl}${t}`,{headers:{"X-Figma-Token":this.apiKey}});if(!i.ok)throw{status:i.status,err:i.statusText||"Unknown error"};return await i.json()}catch(i){throw i.status?i:i instanceof Error?new Error(`Failed to make request to Figma API: ${i.message}`):new Error(`Failed to make request to Figma API: ${i}`)}}async getImageFills(t,i,r){if(i.length===0)return[];let o=[],s=`/files/${t}/images`,n=await this.request(s),{images:l={}}=n.meta;return o=i.map(async({imageRef:d,fileName:g})=>{let a=l[d];return a?A(g,r,a):""}),Promise.all(o)}async getImages(t,i,r){let o=i.filter(({fileType:a})=>a==="png").map(({nodeId:a})=>a),s=o.length>0?this.request(`/images/${t}?ids=${o.join(",")}&scale=2&format=png`).then(({images:a={}})=>a):{},n=i.filter(({fileType:a})=>a==="svg").map(({nodeId:a})=>a),l=n.length>0?this.request(`/images/${t}?ids=${n.join(",")}&format=svg`).then(({images:a={}})=>a):{},d=await Promise.all([s,l]).then(([a,f])=>({...a,...f})),g=i.map(({nodeId:a,fileName:f})=>{let y=d[a];return y?A(f,r,y):!1}).filter(a=>!!a);return Promise.all(g)}async getFile(t,i){try{let r=`/files/${t}${i?`?depth=${i}`:""}`;c.log(`Retrieving Figma file: ${t} (depth: ${i??"default"})`);let o=await this.request(r);c.log("Got response");let s=P(o);return R("figma-raw.yml",o),R("figma-simplified.yml",s),s}catch(r){throw console.error("Failed to get file:",r),r}}async getNode(t,i,r){let o=`/files/${t}/nodes?ids=${i}${r?`&depth=${r}`:""}`,s=await this.request(o);c.log("Got response from getNode, now parsing."),R("figma-raw.yml",s);let n=P(s);return R("figma-simplified.yml",n),n}};function R(e,t){try{if(process.env.NODE_ENV!=="development")return;let i="logs";try{x.accessSync(process.cwd(),x.constants.W_OK)}catch(r){c.log("Failed to write logs:",r);return}x.existsSync(i)||x.mkdirSync(i),x.writeFileSync(`${i}/${e}`,fe.dump(t))}catch(i){console.debug("Failed to write logs:",i)}}import pe from"js-yaml";var me={name:"Figma MCP Server",version:"0.2.1"};function q(e,{isHTTP:t=!1}={}){let i=new ge(me),r=new $(e);return ue(i,r),c.isHTTP=t,i}function ue(e,t){e.tool("get_figma_data","When the nodeId cannot be obtained, obtain the layout information about the entire Figma file",{fileKey:u.string().describe("The key of the Figma file to fetch, often found in a provided URL like figma.com/(file|design)/<fileKey>/..."),nodeId:u.string().optional().describe("The ID of the node to fetch, often found as URL parameter node-id=<nodeId>, always use if provided"),depth:u.number().optional().describe("How many levels deep to traverse the node tree, only use if explicitly requested by the user")},async({fileKey:i,nodeId:r,depth:o})=>{try{c.log(`Fetching ${o?`${o} layers deep`:"all layers"} of ${r?`node ${r} from file`:"full file"} ${i}`);let s;r?s=await t.getNode(i,r,o):s=await t.getFile(i,o),c.log(`Successfully fetched file: ${s.name}`);let{nodes:n,globalVars:l,...d}=s,g={metadata:d,nodes:n,globalVars:l};c.log("Generating YAML result from file");let a=pe.dump(g);return c.log("Sending result to client"),{content:[{type:"text",text:a}]}}catch(s){let n=s instanceof Error?s.message:JSON.stringify(s);return c.error(`Error fetching file ${i}:`,n),{isError:!0,content:[{type:"text",text:`Error fetching file: ${n}`}]}}}),e.tool("download_figma_images","Download SVG and PNG images used in a Figma file based on the IDs of image or icon nodes",{fileKey:u.string().describe("The key of the Figma file containing the node"),nodes:u.object({nodeId:u.string().describe("The ID of the Figma image node to fetch, formatted as 1234:5678"),imageRef:u.string().optional().describe("If a node has an imageRef fill, you must include this variable. Leave blank when downloading Vector SVG images."),fileName:u.string().describe("The local name for saving the fetched file")}).array().describe("The nodes to fetch as images"),localPath:u.string().describe("The absolute path to the directory where images are stored in the project. If the directory does not exist, it will be created. The format of this path should respect the directory format of the operating system you are running on. Don't use any special character escaping in the path name either.")},async({fileKey:i,nodes:r,localPath:o})=>{try{let s=r.filter(({imageRef:f})=>!!f),n=t.getImageFills(i,s,o),l=r.filter(({imageRef:f})=>!f).map(({nodeId:f,fileName:y})=>({nodeId:f,fileName:y,fileType:y.endsWith(".svg")?"svg":"png"})),d=t.getImages(i,l,o),g=await Promise.all([n,d]).then(([f,y])=>[...f,...y]);return{content:[{type:"text",text:!g.find(f=>!f)?`Success, ${g.length} images downloaded: ${g.join(", ")}`:"Failed"}]}}catch(s){return c.error(`Error downloading images from file ${i}:`,s),{isError:!0,content:[{type:"text",text:`Error downloading images: ${s}`}]}}})}he({path:Se(process.cwd(),".env")});async function be(){let e=process.env.NODE_ENV==="cli"||process.argv.includes("--stdio"),t=N(e),i=q(t.figmaApiKey,{isHTTP:!e});if(e){let r=new ye;await i.connect(r)}else console.log(`Initializing Figma MCP Server in HTTP mode on port ${t.port}...`),await k(t.port,i)}process.argv[1]&&be().catch(e=>{console.error("Failed to start server:",e),process.exit(1)});export{N as a,q as b,be as c};
